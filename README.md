# 1 react

https://solid-canidae-759.notion.site/React-a03b4c89666d4bdb82ceac73b6edfa55

---

## 1.1 Про react

- Зачем нужен react?

React - это JavaScript библиотека для создания пользовательских интерфейсов.

1. Использование виртуального DOM для оптимизации производительности.
2. Поддержка SSR через NEXT.js когда разметка подготавливатеся на сервере и в готовом виде передается на клиент.
3. Возможность использования JSX для более удобного написания кода.

---

## 1.2 key

- Для чего нужен key?
- Есть ли кейсы когда key нужен не для списка, а для когда у нас 1 узел?

key нужен для определения уникальности JSX-элементов в массиве.
Благодаря ей react понимает какие именно элементы нужно перерисовывать.
Без неё, при изменении одного из элементов, react будет перерисовывать его со всеми последующими.

Наличие уникального id имеет смысл только на одном и том же уровне уровне.
Если массив изменяется по принципу стека (только в конце), можно использовать индексы.

Вне списка key можно использовать для сброса состояния компонента: присваиваем атрибуту key значение при изменении
которого должна происходить перерисовка.
Но не нужно дублировать такие элементы с одинаковым key, иначе при изменении key, будет размонтирован только последний.
В таких случаях нужно сделать key уникальным для обоих, либо обернуть оба элемента во что-то (чтобы они были на разных
уровнях).

---

## 1.3 useState, useReducer, useContext

- useState и useReducer, когда что?
- Кто мне мешает состояние из useState положить в context?

### 1.3.1 useState

https://reactdev.ru/reference/react/useState/

Позволяет добавить переменную состояния в компонент.

```
const [val, setVal]=useState(0)

const handle=()=>{
    setVal((i)=>{
        return i+1
    })
}

<p>{val}</p>
<button onClick={handle}>Increment</button>
```

### 1.3.2 useReducer

https://reactdev.ru/reference/react/useReducer/

Используется для управления состоянием компонентов. В отличие от useState, который предоставляет простое локальное
состояние для функциональных компонентов, useReducer используется для управления более сложными состояниями и выполнения
действий (actions) на этом состоянии.

```
const initialState={val: 0};

const reducer=(state, action)=>{
  switch (action.type) {
        case 'increment':
          return {val: state.val+1}
        default:
          throw new Error()
  }
};

const [state, dispatch] = useReducer(reducer, initialState)

const handle=()=>{
    dispatch({
        type: 'increment'
    })
}

<p>{state.val}</p>
<button onClick={handle}>Increment</button>
```

### 1.3.3 useContext

https://reactdev.ru/reference/react/useContext/

Используется для получения доступа к значению контекста изнутри функционального компонента.

```
const Con=createContext(null);
const [val, setVal]=useState(0)
const handle=()=>{
    setVal((i)=>{
        return i+1
    })
}

<Con.Provider value={val}>
    <button onClick={handle}>Increment</button>
    <CompName/>
</Con.Provider>

const val=useContext(Con)

<p>{val}</p>
```

### 1.3.4 Почему useReducer, а не useState + useContext

При useState + useContext нам придётся запихнуть сеттеры в value провайдера их родительского компонента.
Но если логика будет сложной, мы сделаем handle функцию и будем передавать её.
Тогда при перерендере родителя будет создаваться новая handle функция, из за чего будет перерендериваться и потомок.

А у useReducer сеттер между повторными рендерингами не меняется, а сложная handle логика пишется в reducer.

---

## 1.4 useRef

https://reactdev.ru/reference/react/useRef/

- useRef, для чего нужен?
- Как сохранять через useRef, что туда можно положить?

Используется для создания изменяемых значений внутри компонента и сохранения ссылок на DOM-элементы. Он позволяет
сохранять значения между рендерами компонента и обновлять их без вызова повторного рендера. useRef() также может
использоваться для хранения промежуточных значений и функций внутри компонента.

```
const ref=useRef(null)

<input ref={ref} type="text"/>
<button onClick={()=>ref.current.focus()}>setFocus</button>
```

---

## 1.5 useEffect, useLayoutEffect

- Для чего нужен useEffect?
- В чём разница между useEffet и useLayOutEffect?
- Зачем нужна функция отчистки / возвращаемый callBack?

### 1.5.1 useEffect

https://reactdev.ru/reference/react/useEffect/

Предоставляет возможность выполнения побочных эффектов в функциональных компонентах АСИНХРОННО, обычно вызывается после
отрисовки компонента. Побочные эффекты включают в себя такие операции, как загрузка данных с сервера, подписка на
события DOM, изменение заголовка документа и т. д. useEffect выполняет эти действия после каждого рендера компонента.

```
useEffect(()=>{}) или useEffect(()=>{},null)
вызывается при создании компонента (аналогично componentDidMount(){})
и при обновлении компонента (аналогично componentDidUpdate(){})

useEffect(()=>{},[valName])
вызывается при создании компонента (аналогично componentDidMount(){})
и при обновлении компонента, если valName изменится

useEffect(()=>{},[])
вызывается только при создании компонента (аналогично componentDidMount(){})
```

### 1.5.2 useLayoutEffect

https://reactdev.ru/reference/react/useLayoutEffect/

Это версия useEffect, которая срабатывает перед тем, как браузер перерисовывает экран.
Код внутри useLayoutEffect и все запланированные обновления состояния блокируют браузер от перерисовки экрана (РАБОТАЕТ
СИНХРОННО). При чрезмерном использовании это делает ваше приложение медленным. Когда это возможно, предпочитайте
useEffect.

```
useLayoutEffect(()=>{},[])
```

---

## 1.6 useMemo, useCallback

- Для чего нужен useMemo?
- что ты имеешь ввиду под pureComponent?
- что такое pureComponent в мире хуков?
- в чём разница между useMemo и React.memo?
- какие кейсы для useMemo, кроме тяжелых вычислений?
- для чего нужен useCallback?

В программировании мемоизация - это метод оптимизации, который делает приложения более эффективными и, следовательно,
более быстрыми. Он делает это, сохраняя результаты вычислений в кэше и извлекая ту же информацию из кэша в следующий
раз, когда она потребуется, вместо того, чтобы вычислять ее снова.

### 1.6.1 useMemo

https://reactdev.ru/reference/react/useMemo/

Используется для мемоизации вычислений в функциональных компонентах. Это позволяет избегать повторного вычисления
значений при каждом рендере компонента, что может повысить производительность приложения.

```
const memoFunc=useMemo(funcName,[])
```

### 1.6.2 useCallback

https://reactdev.ru/reference/react/useCallback/

Используется для мемоизации функций и предотвращения их повторного создания при каждом рендере компонента.
Мемоизированная функция так же запоминает свое окружение.

```
const memoFunc=useCallback(funcName,[])
```

---

### 1.6.3 memo

memo - это HOC, позволяет пропустить повторный рендеринг компонента, если его пропсы неизменны.

```
const MemoComp = memo(CompName, (oldProps, newProps)=>{
    return true // равны, не рендерим
})
```

---

## 1.7 useTransition и useDefaultValue

- Интересные хуки связанные с оптимизацией рендеринга: useTransition и useDefaultValue?

### 1.7.1 useTransition

https://reactdev.ru/reference/react/useTransition/

Позволяет обновлять состояние без блокировки пользовательского интерфейса.

Переходы позволяют сохранить отзывчивость обновлений пользовательского интерфейса даже на медленных устройствах.

С помощью перехода пользовательский интерфейс остается отзывчивым в середине повторного рендеринга. Например, если
пользователь нажал на вкладку, но затем передумал и нажал на другую вкладку, он может сделать это, не дожидаясь
окончания первого повторного рендеринга.

```
const [isPending, startTransition]=useTransition()
```

Флаг isPending, который сообщает, есть ли ожидающий переход.
Функция startTransition, позволяющая пометить обновление состояния как переход.

### 1.7.2 useDeferredValue

https://reactdev.ru/reference/react/useDeferredValue/

Позволяет отложить обновление состояния компонента до момента, когда он неактивен или до завершения других приоритетных
задач.

Во время первоначального рендеринга отложенное значение будет таким же, как и предоставленное вами значение.

Во время обновлений отложенное значение будет "отставать" от последнего значения. В частности, React сначала выполнит
рендеринг без обновления отложенного значения, а затем попытается выполнить рендеринг с вновь полученным значением в
фоновом режиме.

```
const [query, setQuery]=useState('')
const deferredQuery=useDeferredValue(query)
```

Во время первоначального рендеринга отложенное значение будет таким же, как и предоставленное вами значение.

Во время обновлений отложенное значение будет "отставать" от последнего значения. В частности, React сначала выполнит
рендеринг без обновления отложенного значения, а затем попытается выполнить рендеринг с вновь полученным значением в
фоновом режиме.

---

## 1.8 lazy

- Что такое lazy?

«Ленивая» (Lazy) функция в React - это функция, которая загружает компоненты только тогда, когда они действительно
нужны, а не заранее. Это позволяет ускорить начальную загрузку приложения и уменьшить объем передаваемого кода. В React
для создания «ленивых» функций используется функция lazy(), которая принимает функцию импорта компонента, который будет
загружаться только при необходимости.

```
const LazyComponent=React.lazy(()=>import('./LazyComponent'));

Используем Suspense для отображения заглушки во время загрузки
<Suspense fallback={<div>Loading...</div>}>
  Обертка для лениво загружаемого компонента
  <LazyComponent/>
</Suspense>
```

---

# 2 redux

https://solid-canidae-759.notion.site/State-management-8dad2933eb8946d7a563f64067988628

---

## 2.1 Redux.query

- Использовал ли ты Redux.query?

**React Query**- библиотека для получения, кэширования, синхронизации и обновления "серверного" состояния в
React-приложениях.

**Плюсы:**

- Упрощение запросов.
- Встроенное кэширование данных.
- Автоматическая обработка ошибок.
- Автоматические запросы на сервер для актуализации данных (например через определенный интервал времени или при
  фокусировании на приложении).
- Инвалидация кэша и его автоматическое обновление. Инвалидация - это процесс обозначения кэшированных данных как
  устаревших или недействительных.

- **useQuery** : Позволяет выполнить запрос к серверу для получения данных.
- **useQueries** : Использоваться для выполнения нескольких запросов.
- **useInfiniteQuery** : Позволяет загружать данные пачками (пагинация) и автоматически управлять загрузкой следующих
  страниц данных. Полезен, когда необходимо загружать большие объемы данных частями.
- **useMutation** : Используется для выполнения мутаций на сервере, таких как создание, обновление или удаление данных.
  “Аналог” POST/PUT/DELTE.
- **useQueryClient** : Предоставляет доступ к экземпляру **QueryClient**, который содержит методы для управления кэшем
  запросов.

```
  return useQuery('countries', getCountry, {
    onError: (error) => {
      if (error instanceof Error) {
        toast({
          status: 'error',
          title: error.message,
          position: 'top',
        });
      }
    },
  });
```

**Принимает:**

- Строку, представляющую ключ запроса. При передаче строки в качестве ключа запроса, она преобразуется в массив с
  единственным элементом.
- Возможно передать массив в качестве ключа запроса. Это позволяет создавать более сложные ключи запроса, которые могут
  включать в себя несколько параметров.

## 2.2 Middleware

- Зачем нужен Middleware?
- а почему я не могу сделать эти штуки уже в store?

Middleware — это функция, которая расширяет функциональность dispatch. Эта функция принимает store (но не весь, а только
dispatch и getState.) и возвращает функцию, которая принимает next (ссылку на следующую middleware или редьюсер) и
возвращает еще одну функцию, которая принимает action.

**Процесс выглядит следующим образом:**

- **Middleware** получает **store**.
- **Middleware** возвращает функцию, которая получает **next →** **next** возвращает следующую **middleware** в цепочке,
  если такая существует. Если **next** является последней **middleware** в цепочке, она возвращает функцию редьюсера.
- Внутри этой функции, **middleware** возвращает еще одну функцию, которая получает **action**.
- В этой функции **middleware** может выполнить свою логику до или после передачи действия следующему **middleware** или
  **редьюсеру**, используя **next**(**action**).

**Другой источник:**

Люди используют промежуточное программное обеспечение Redux для ведения журналов, отчетов о сбоях, взаимодействия с
асинхронным API, маршрутизации и многого другого.

Лучшая особенность промежуточного программного обеспечения заключается в том, что его можно компоновать в цепочку.

---

# 3 ts

https://solid-canidae-759.notion.site/TypeScript-b49f4ef352394cddb50b61bb70d4c56c

---

## 3.1 Про ts

- Зачем нужен ts?

Главная причина использовать TypeSciprt - это возможность добавить статическую типизацию к JavaScript. Тип переменной со
статической типизацией не может быть изменен после ее объявления. Это может предотвратить БОЛЬШОЕ количество багов.

Почему вам нужно использовать TypeScript:

- Исследование показало, что TypeScript может обнаружить 15% самых частых багов.
- Читаемость - намного проще видеть, что делает код. А при работе в команде проще видеть, что делают другие
  разработчики.
- Популярность - знание TypeScript позволит вам расширить круг вакансий, на которые вы сможете претендовать.
- Изучение TypeScript даст вам лучшее понимание и новый взгляд на JavaScript.

---

## 3.2 Типы в ts

- Чем any отличается от unknown?
- Когда используется тип never?

Типы в ts:

- boolean (логический тип)
- number (числовой тип)
- string (строковый тип)
- array (массив)
- tuple (кортеж)
- enum (перечисление)
- null и undefined
- object (не примитивный тип данных)
- any (любой тип)
- void (отсутствие значения) : функции, которые не возвращают значения
- never (тип, который не имеет значений) : функции, которые никогда не завершаются (например, функция, которая всегда
  выбрасывает исключение или содержит бесконечный цикл)
- unknown : используется для значений, о типе которых мы не знаем на момент компиляции. Он похож на тип any, но более
  безопасен, так как TypeScript не позволяет присваивать значения типа unknown переменным других типов без явного
  приведения типов.

Тип Unknown является типобезопасным аналогом типа any и представлен в виде литерала unknown. Все типы совместимы с типом
unknown, в то время как сам тип unknown совместим только с самим собой и типом any.

Кроме того, над типом unknown запрещено выполнение каких-либо операций.

Если тип unknown составляет тип пересечение (intersection), то он будет перекрыт всеми типами.

Если тип unknown составляет тип объединение (union), то он перекроет все типы, за исключением типа any.

Помимо этого, запрос ключей (keyof) для типа unknown возвращает тип never.

Тип unknown позволяется использовать только в операциях равенства ===, ==, !== и != и в операциях с логическими
операторами &&, || и !.

https://scriptdev.ru/guide/014/#unknown

---

## 3.2 void, any, unknown, never

- Чем any отличается от unknown?

text

---

## 3.3 never

- Когда используется тип never?

text

---

## 3.4 Generic

- Что такое Generic?

Общие типы (generic) в TypeScript позволяют создавать функции, классы и интерфейсы, которые могут работать с различными
типами данных без необходимости явного указания конкретных типов.

https://htmlacademy.ru/blog/js/typescript-generic

---

## 3.5 type, interface

- Разница между type и interface?

1. Интерфейсы могут быть расширены и реализованы, а типы - нет.
2. Интерфейсы могут наследовать свойства и методы других интерфейсов, а типы - нет.
3. Типы могут быть использованы только для определения формы объектов, а интерфейсы могут быть использованы для
   определения формы объектов, классов и функций.
4. Интерфейсы могут иметь перегруженные методы, а типы - нет.
5. Использование интерфейсов более распространено в сообществе TypeScript, чем использование типов.

---

## 3.6 index.ts, index.d.ts

- Разница между index.ts и index.d.ts / для чего нужны файлы декларации?

*.d.ts файлы - это файлы декларации типов. Они содержат описание типов без реализации. Например, сигнатуры функций без
тела, название и тип глобальных переменных без значений. В основном файлы декларации типов нужны для написания
библиотек. Они нужны тогда, когда:

вы написали библиотеку и хотите, чтобы ее можно было использовать не только в TypeScript проектах

вы хотите использовать библиотеку, которая написана на JavaScript.

**Другой источник:**

Декларации размещаются в файлах с расширением .d.ts и состоят только из объявлений типов полностью повторяющих программу
до момента компиляции при которой она была лишена всех признаков типизации.

**Другой источник:**

Если у вас есть файл JavaScript и вы хотите добавить к нему информацию с расширенным типом, вы можете сделать это в
файле объявления. Это похоже на разделение TypeScript между двумя файлами; файл JavaScript .js только с простым
JavaScript и файл декларации .d.ts со всей информацией о типе.

Это означает, что между файлами есть некоторая избыточность.

Обычно, если вы пишете библиотеку TypeScript, вы автоматически генерируете файл JavaScript и декларации и упаковываете
их, а не исходный TypeScript. Это означает, что библиотеку можно использовать из приложений JavaScript и TypeScript, и
позволяет используемой библиотеке использовать версию TypeScript, отличную от вашей.

**Другой источник:**

Файлы определений, сгенерированные компилятором TypeScript, действительно в основном повторяют написанный вами код, но с
некоторыми заметными отличиями:

- Они не содержат реализации, только декларации
- Они содержат только общедоступные типы

- Эти файлы объявлений используются для распространения библиотек. Вы можете распространять библиотеку без исходного
  кода TypeScript (поскольку это в любом случае не имеет значения во время выполнения) и распространять только
  скомпилированный JavaScript. Потребители JavaScript будут использовать JavaScript и не заботиться о его происхождении.
  Потребители TypeScript также будут использовать JavaScript во время выполнения, но файлы .d.ts позволят компилятору
  проверить код, даже если исходный источник TypeScript для библиотеки отсутствует.

Этот же подход можно также использовать для разделения большого проекта на несколько более мелких проектов, которые
используют файлы объявлений для установления интерфейса между ними. Каждый проект можно перекомпилировать независимо без
перекомпиляции всех проектов, что сокращает время компиляции. Компилятор TypeScript фактически планирует добавить
встроенную поддержку для этого в будущем.

---

# 4 js

---

## 4.1 ==, ===

- Разница между == и ===?

Оператор == (нестрогое равенство) - приводит оба операнда к одному типу и сравнивает.

Оператор === (строгое равенство) - не приводит к одному типу.

**Falsy типы:**

- `‘’`
- `0`
- `undefiend`
- `null`
- `NaN`

## 4.2 Типы данных js

- Типы данных js?

Семь из них называют «примитивными» типами данных:

- `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(
  253-1).
- `bigint` для целых чисел произвольной длины.
- `string` для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
- `boolean` для `true/false.`
- `null` для неизвестных значений – отдельный тип, имеющий одно значение `null`.
- `undefined` для не присвоенных значений – отдельный тип, имеющий одно значение `undefined`.
- `symbol` для уникальных идентификаторов.

И один не является «примитивным» и стоит особняком:

- `object` для более сложных структур данных.

## 4.3 Дескрипторы

- Что такое дескрипторы?

Объекты, как мы знаем, содержат свойства. У каждого из свойств объекта, кроме значения, есть ещё три флага конфигурации,
которые могут принимать значения true или false. Эти флаги называются дескрипторами:

writable — доступно ли свойство для записи;
enumerable — является ли свойство видимым при перечислениях (например, в цикле for..in);
configurable — доступно ли свойство для переконфигурирования.
Когда мы создаём свойство объекта «обычным способом», эти три флага устанавливаются в значение true.

Для изменения значений дескрипторов применяется статический метод Object.defineProperty(), а для чтения значений —
Object.getOwnPropertyDescriptors().

Другими словами, дескрипторы — это пары ключ-значение, которые описывают поведение свойства объекта при выполнении
операций над ним (например, чтения или записи).

```
const laptop = {}

Object.defineProperty(laptop, 'os', {
  value: 'MacOS',
  writable: false,
  enumerable: true,
  configurable: true
})
```

## 4.4 Прототипы

- Что такое прототипы и зачем они нужны?
- как узнать прототип объекта?
- свойство prototype у объекта?
- что ты имеешь ввиду под конструктором?

Прототип это обьект, который послужил шаблоном для создания дочернего объекта, предоставил ему свои поля и методы.

Прототип - это объект, который используется в качестве шаблона для создания других объектов. Каждый объект в JavaScript
имеет ссылку на свой прототип, который определяет его свойства и методы. Если свойство или метод не найден в самом
объекте, JavaScript будет искать его в прототипе этого объекта, затем в прототипе прототипа и так далее, пока не будет
найдено или не достигнут конец цепочки прототипов (Object.prototype). Прототипы позволяют создавать иерархию объектов и
упрощать наследование свойств и методов.

Прототипное наследование - это особенность JavaScript, которая позволяет объектам наследовать свойства и методы других
объектов через использование их прототипов. В JavaScript каждый объект имеет ссылку на прототип, который является другим
объектом.

__**proto**__ - есть у всех объектов! Это ссылка на **.prototype** того класса, с помощью которого создан обьект.

**.prototype** - есть только у **function** и **class.**

Когда к свойству объекта происходит обращение, и если свойство не находится в текущем объекте, то механизм JavaScript
просматривает прототип объекта и ищет это свойство там, затем в прототип прототипа и так пока не найдет нужное свойство
или не дойдет до конца цепочки прототипов.

**Создать объект без прототипа:**

- Object.create(null)

## 4.5 this

- Что такое this?
- что значит где мы находимся?
- что такое лексическое окружение?

**this** - это контекст выполнения функции.
Ключевое слово this в JavaScript используется для ссылки на объект, в котором выполняется код.

**Область видимости** - это место откуда мы имеем доступ к переменным или функциям. Также область видимости это по сути
набор правил по которым ищется переменная. Сначала в локальной, затем во внешней и т.д. пока не дойдет до глобальной.

**Лексическое окружение** - это НЕ набор правил где ищется переменная (лексическое окружение - комната).
Лексическое окружение возникает в момент исполнения кода (если мы применяем к функции, то это момент вызова функции,
тогда возникает лексическое окружение; когда вызвал одну функцию 3 раза, то будет 3 разных лексических окружения).

* lexical environment - лексическое окружение (комната)
* контекст - "комната" в которой находитмся сущность
* scope - область видимости (видимые "комнаты": всплывает до window, но не погружается)
* window - глобальный объект на самом верхнем уровне внутри которого находятся все остальные
* hoisting - поднятие/всплытие

Значение `this` зависит от контекста выполнения.
Контекст можно определить на основе трех вопросов:

- Включен строгий режим или нет?
- Какая функция используется?
- Как функция вызывается?

В функциях, созданных при помощи ключевого слова function:

- this определяется в момент вызова
- this можно задать явным образом через методы call, apply и bind

В стрелочных функциях:

- Нет своего this, они берут его из внешнего окружения в момент создания
- Нельзя присвоить this методами call, apply и bind
- НЕ теряют this
- В методе объекта, созданном через стрелочную функцию, this === window, ВСЕГДА! НЕ ВАЖНО КАКОЙ РЕЖИМ!

this у глобальной области видимости:

- Без 'use strict': this === window
- С 'use strict': this === undefined

this у методов объектов:

- равен объекту, но только в том случае, если мы вызываем метод через объект
- Если присвоить метод объекта в переменную и вызвать переменную как функцию, или передать метод в таймер, то он будет
  вызываться как обычная функция и this потеряется

this в конструкторах и классах:

- this === экземпляру объекта

## 4.6 Принцип асинхронности

- Что в приоритете: макротаски или микротаски?

событийный цикл: скрипт => одна макрозадача => все микрозадачи => рендеринг => заново к одной макрозадаче

- Интерпритатор:
  то что идёт по коду js сверху вниз
- Call Stack (выполнялка):
  когда интерпритатор идёт по коду, он кидаёт все зачдачи в Call Stack где они сразу же исполняются
  если в Call Stack попадает что-то, чему надо отстояться (например, setTimeout), то оно улетает в Web Apis, вместо
  исполнения
- Web Apis (ожидалка):
  сюда попадает всё, чему надо отстояться (например: setTimeout, addEventListener, ...)
  setTimeout просто крутит свой таймер в Web Apis, а потом отпраляет вложеннй код в Callback Queue, после чего удаляется
  из Web Apis
  addEventListener таймера не имеет и остаётся в Web Apis жить, каждый раз когда будет происходить заложенный еvent,
  вложеннй код будет отправляться в Callback Queue
- Callback Queue (очередь в выполнялку):
  очередь, ожидающая когда Event Loop запустит их в Call Stack
- Event Loop (смотрящий за очередью в выполнялку):
  цикл, ожидающий когда Call Stack опустеет, после чего делает итерацию по Callback Queue
  и поочерёдно запускает нахоящиеся там команды в Call Stack

микрозадачи:

- операции с промисами (например, Promise.then(), Promise.catch(), fetch() и так далее);
- операции с очередью мутации (например, используемые в API MutationObserver для наблюдения за изменениями DOM);
- операции, связанные с queueMicrotask(), — функцией для явного добавления микрозадач.

макрозадачи:

- обработка таймеров (setTimeout, setInterval);
- обработка событий пользовательского ввода (например, клики, скроллинг);
- выполнение AJAX-запросов.

## 4.7 requestAnimationFrame()

- requestAnimationFrame?

При написании кода, мы вручную устанавливаем, как именно будет происходить анимация покадрово. Частота кадров на
мониторе и частота перерисовки браузером контента может быть не постоянной, это зависит от нагрузки, сколько
одновременно запущено программ на компьютере клиента. В таких случаях можно наблюдать, как какие-то кадры замирают.
Вдобавок частота кадров стремится к какому-то значению. Вот тогда и происходит рассинхронизация: setTimeout принуждает
перерисовывать кадры, не синхронно со сменой кадров у компьютера. Однако самая большая проблема состоит в том, что если
открыто несколько вкладок браузера, и на одной из них есть анимация, то она все равно работает, активна эта вкладка или
нет. В результате, все это ведет к избыточной нагрузке на компьютер.

Функция requestAnimationFrame была создана для решения всех вышеперечисленных проблем. У нее достаточно высокая
поддержка среди браузеров. Функция requestAnimationFrame позволяет нам запускать какие-то другие функции в качестве
анимаций. Она берет вашу анимацию и подстраивает ее под частоту обновления вашего браузера. Делая так, что ваша анимация
будет происходить в тот момент, когда обновляется страничка. Добиваясь плавности анимации и при этом не нагружая
компьютер. А если на страничке прописано несколько анимаций, то запускаться они будут одновременно. Звучит хорошо, не
правда ли?

```
function myAnimation() {
    pos++; // Увеличиваем позицию квадрата на единицу
    elem.style.top = pos + "px"; // Устанавливаем значение top для инлайн стилей у квадрата
    elem.style.left = pos + 'px'; // // Устанавливаем значение left для инлайн стилей у квадрата

    if (pos < 300) {
        requestAnimationFrame(myAnimation); // Запуск анимации
    }
}

btn.addEventListener('click', () => requestAnimationFrame(myAnimation));

let id = requestAnimationFrame(myAnimation);
cancelAnimationFrame(id);
```

requestAnimationFrame запускает функцию myAnimation() в виде коллбэка. Когда позиция элемента станет меньше 300, то
нужно запустить анимацию, а если больше, то остановить анимацию. За запуск анимации отвечает requestAnimationFrame,
таким образом происходит зацикливание анимации. И когда анимация выполнится 300 раз, то перестанет запускаться.

Для запуска анимации в первый раз, отслеживаем клик по кнопке btn и вызываем requestAnimationFrame. Для отмены анимации,
нужно вызвать метод cancelAnimationFrame с уникальным идентификатором.

**Другой источник:**

Метод requestAnimationFrame предоставляет разработчикам доступ к жизненному циклу фрейма, позволяя выполнять операции
перед вычислением стилей и формированием макета (layout) документа браузером. Вот почему данный метод отлично подходит
для реализации анимации. Собственно, для этого он и предназначен.

Во-первых, он вызывается не чаще и не реже, чем браузер вычисляет макет (правильная частота). Во-вторых, он вызывается
перед формированием макета (правильное время). Поэтому rAF также отлично подходит для внесения изменений в DOM или
CSSOM. Он синхронизирован с vsync, как и любой другой механизм рендеринга, используемый браузером.

---

# 5 webCore

---

## 5.1 cookie, localStorage, sessionStorage

- Что такое cookie?
- если лучше использовать localStorage или sessionStorage, как тогда общаться с сервером?
- в чём разница между localStorage и sessionStorage?
- могут ли разные домены смотреть в localStorage друг друга?

LocalStorage — это объект, предоставляемый браузером, который позволяет хранить данные без срока действия. Это означает,
что данные, сохраненные с помощью localStorage, не будут удалены после закрытия браузера и останутся доступными при
следующем открытии веб-сайта. LocalStorage идеально подходит для хранения данных, которые необходимо сохранить на
длительный срок, например, информации о предпочтениях пользователя.

SessionStorage очень похож на localStorage с тем отличием, что данные, сохраненные в sessionStorage, удаляются после
закрытия браузера. Это делает sessionStorage идеальным для хранения данных, которые актуальны только в рамках одной
сессии, например, данные формы, которую пользователь заполняет.

Cookies — это небольшие текстовые файлы, которые веб-сайт может записать на компьютер пользователя. Они могут хранить
небольшое количество данных (до 4КБ) и имеют срок действия, который можно установить при записи cookie.
Cookies могут быть доступны на всех страницах сайта и сохраняться между сессиями, что делает их идеальными для
идентификации пользователя. Однако они могут быть отключены пользователем, что делает их ненадежным методом хранения.

### 5.1.1 HTTP cookie

**HTTP Cookie** - это небольшой фрагмент данных отправляемых сервером на браузер пользователя, который тот может
сохранить и отсылать обратно с новым запросом к данному серверу.

При обращении к серверу он возвращает куки, которые потом при каждом запросе на сервер передаются вместе с запросом, так
сервер может идентифицировать пользователя и например не запрашивать авторизацию повторно.

**Используются для:**

- Управление сеансом (логины, токены)
- Мониторинга, отслеживания поведения пользователя
- Персонализации (пользовательские предпочтения)

### 5.1.1 Безопасные куки / HttpOnly cookies

**Безопасные куки** - отправляются на сервер только если запрос выполняется по протоколу SSL и HTTPS. Но важные данные
все равно не стоит передавать или хранить в cookies, т.к. они сами по себе уязвимы и флаг secure не обеспечивает
никакого шифрования или средств защиты. Сайты с протоколом HTTP не могут создавать cookie с флагом secure.

**HttpOnly Cookie** - недоступны из JavaScript, что обеспечиватет защиту от XSS. Используется для тех cookie к которым
не требуется обращаться через JS, например если используются только для поддержки сессии.

---

## 5.2 CORS, SCP, XSS

- Что такое CORS?
- кто управляет CORSами?
- что такое SCP?
- что такое XSS?

### 5.2.1 CORS

**CORS** (Cross-Origin Resource Sharing — «совместное использование ресурсов между разными источниками») — это механизм,
который позволяет веб-страницам запрашивать ресурсы с другого домена, отличного от домена, с которого была загружена
сама страница.

По умолчанию, в целях безопасности, веб-браузеры ограничивают кросс-доменные запросы с использованием политики одного
источника (**Same-Origin Policy**). Он предоставляет веб-серверам возможность явно разрешить некоторые кросс-доменные
запросы, сохраняя при этом безопасность.

**Как он работает**

Когда веб-приложение пытается сделать запрос к ресурсу, который находится на другом домене (кросс-доменный запрос),
браузер автоматически добавляет к запросу заголовок **Origin**.

Этот заголовок содержит домен, с которого был сделан запрос. Веб-сервер, к которому направлен запрос, затем проверяет
этот заголовок и решает, разрешить ли запрос. Если сервер разрешает запросы из этого источника, он отвечает с
соответствующими CORS заголовками, указывающими, какие действия разрешены.

Один из таких заголовков — **`Access-Control-Allow-Origin`**, который может быть установлен в `*` (что означает
разрешение для всех доменов) или в конкретный домен.

**Примеры:**

- **`Access-Control-Allow-Origin`**: Указывает, какие домены могут получать доступ к ресурсу. Может быть установлен в
  конкретный домен или `*` для разрешения всех доменов.
- **`Access-Control-Allow-Methods`**: Указывает, какие HTTP методы разрешены при доступе к ресурсу.
- **`Access-Control-Allow-Headers`**: Указывает, какие HTTP заголовки могут быть использованы во время запроса.
- **`Access-Control-Allow-Credentials`**: указывает, разрешено ли передавать куки и авторизационные заголовки при
  доступе к ресурсам.

**Почему CORS важен**

Решает важную проблему безопасности, позволяя контролировать, какие веб-сайты могут использовать ресурсы вашего
веб-сайта. Это предотвращает множество видов атак, таких как CSRF (Cross-Site Request Forgery — подделка межсайтовых
запросов), позволяя при этом легитимным сайтам запрашивать данные через браузер.

**Проблемы с CORS**

Хотя он повышает безопасность, неправильная настройка CORS может привести к уязвимостям. Например, слишком широкое
использование

```
Access-Control-Allow-Origin: *
```

может случайно разрешить небезопасные кросс-доменные запросы. Разработчики должны тщательно настраивать политики CORS,
чтобы избежать потенциальных проблем с безопасностью.

**CORS** является ключевым элементом современной веб-разработки, позволяя безопасно реализовывать кросс-доменные запросы
и взаимодействия между веб-приложениями. Правильное понимание и настройка CORS необходимы для обеспечения безопасности и
гибкости веб-приложений.

**CORS** позволяет защитить веб-приложения от несанкционированного доступа к их ресурсам, но при этом позволяет браузеру
безопасно загружать данные с других доменов.

Два URL имеют «одинаковый источник» в том случае, если они имеют совпадающие протокол, домен и порт.

**Эти URL имеют одинаковый источник:**

- http://site.com
- http://site.com/
- http://site.com/my/page.html

**Проблему CORS можно решить с помощью:**

1. Отключение CORS-проверок в браузере (самый удобный и простой способ)
2. Использование браузерных расширений, таких как CORS Everywhere, которые позволяют обойти ограничения CORS.
3. Можно запустить локальный proxy сервер, который будет пересылать данные между нашим приложением и сервером, добавляя
   необходимые заголовки
4. Использование JSONP (JSON with Padding) для получения данных с другого домена. JSONP позволяет получить данные с
   другого домена, обернув их в функцию, которая вызывается на веб-странице.

CORS позволяет сайту A дать разрешение сайту B на чтение (потенциально конфиденциальных) данных с сайта A (используя
браузер и учетные данные посетителя).

CSP позволяет сайту на котором установлен этот заголовок предотвратить загрузку (потенциально вредоносного) содержимого
из неожиданных источников (например, в качестве защиты от XSS).

### 5.2.2 CSP

**CSP** - это HTTP заголовок, который позволяет операторам сайта детально контролировать откуда могут быть загружены
ресурсы на их сайт.

Использование этого заголовка это лучший способ предотвратить XSS.

Является обязательным для всех новых сайтов и рекомендуется к внедрению несуществующих сайтах с высоким уровнем риска.

Настройка заголовка в соответствии со списком доверенных источников из которых можно получать контент.

**Другой источник:**

Content Security Policy (CSP) - это механизм безопасности веб-приложений, который используется для сокращения рисков,
связанных с атаками, такими как внедрение скриптов (XSS) и выполнение нежелательного кода (инъекция). CSP позволяет
веб-разработчикам указывать браузерам, из каких источников разрешено загружать ресурсы, такие как скрипты, стили,
изображения, шрифты и другие элементы.

С помощью CSP можно определить набор допустимых источников для каждого типа ресурса, а браузеры будут блокировать
попытки загрузки ресурсов из недопустимых источников. Например, вы можете настроить CSP таким образом, чтобы разрешить
загрузку скриптов только из определенного домена или разрешить загрузку стилей только из локального файла.

Это помогает предотвратить атаки, основанные на выполнении вредоносного кода из внешних источников, а также уменьшает
риски, связанные с подделкой источников, перехватом данных и другими видами атак. CSP является эффективным инструментом
для укрепления безопасности веб-приложений и защиты пользователей от различных видов уязвимостей.

### 5.2.3 XSS

**Межсайтовый скриптинг (XSS)** - это довольно распространенная уязвимость, которую можно обнаружить на множестве веб
приложений

**Суть** - злоумышленнику удается внедрить на страницу JS код, который не был предусмотрен разработчиками, и этот код
будет выполняться каждый раз, когда пользователи будут заходить на страницу веб приложения куда этот код был добавлен.

Например злоумышленнику удастся заполучить авторизационные данные пользователя и войти в его аккаунт.

Или злоумышленник может незаметно для жертвы перенаправить его на другую страницу-клон. Эта страница может выглядеть
совершенно идентично той, на которой пользователь рассчитывал оказаться. Но вот принадлежать она будет злоумышленнику.
Если пользователь не заметит подмены и на этой странице введет какие-то sensitive data, то есть личные данные, они
окажутся у злоумышленника.

Например, можно добавить JavaScript-код в поле ввода, текст из которого сохраняется и в дальнейшем отображается на
странице для всех пользователей. Это может быть поле для ввода информации о себе на странице профиля социальной сети или
комментарии на форуме.

Злоумышленник вводит текст (и за одно вредоносный код), который сохраняется на странице. Когда другие пользователи
зайдут на эту же страницу, вместе с текстом они загрузят и JavaScript-код злоумышленника. Именно в момент загрузки этот
код отработает.

---

## 5.3 http.1, http.2

- Разница между http.1 и http.2?
- как понять что данные могут дробиться, когда они и так дробятся?
- что такое мультиплексирование?

HTTP/2 обеспечивает более эффективное использование сети и повышенную производительность в сравнеии с HTTP/1

- **Мультиплексирование** - запросы и ответы могут быть разделены на фрагмены или кадры, и отправлять параллельно по
  одному соединению, что снизижает время ожидания на окончание завершения предыдущего запроса и эффективнее использовать
  сеть. Один из основных плюсов второй версии HTTP. В предыдущей версии для одного запроса была необходима установка
  отдельного TCP-соединения. И чем больше было запросов, тем медленней работал браузер. Благодаря мультиплексированию
  браузер отправляет сразу несколько запросов через одно TCP-соединение. Современные браузеры задействуют ограниченное
  число TCP-соединений, что не позволяет им быстро загружать «тяжелые» страницы. А http/2, где внедрена технология
  мультиплексирования, дает возможность загружать большое количество статического контента одновременно, существенно
  повышая производительность.
- **Компрессия заголовков** - использует алгоритм сжатия что позволяет сократить объем передаваемых данных и снизить
  нагрузку на сеть
- **server push** - серверные уведомления, сервер может активно отправлять ресурсы клиенту которые клинет может
  потенциально запросить, даже до того как этот запрос выполнен явно.
- **Приоретизация** - позволяет установить приоритеты для различных запросов. что помогает оптимизировать поток данных и
  улучшает производительность при обработке параллельных запросов. Суть заключается в том, что браузер запрашивает у
  сервера отдельную загрузку некоторых элементов контента, к примеру, сначала скриптов JavaScript, а затем изображений.
  Приоритезация в протоколе не обязательна, но рекомендована, потому что мультиплексирование не способно полноценно
  работать без приоритетов. Чревато это медленной загрузкой, даже хуже, чем в http 1.1 версии. Ресурсы вторичного
  приоритета, занимая полосу, негативно скажутся на производительности.
- **Безопасность** - обязательно требует шифрование с помощью протокола TLS что обеспечивает повышенную безопасность.

Мультиплексирование в HTTP/2 позволяет отправлять несколько запросов и ответов параллельно по одному соединению. Это
достигается путем разделения запросов на маленькие фрагменты называемые кадрами и передачей их независимо друг от друга.

Выполняется в 4 шага:

- Установление соединения
- Разделение на кадры, которые могут передаваться в любом порядке, каждый кадр сожержит определенную часть данных:
  заголовков, тела запроса или ответа
- Идентификация кадров - каждый кадр имеет уникальный идентификатор который позволяет получателю собрать запросы и
  ответы из кадров в правильном порядке
- Параллельная передача - клиент и сервер могут параллельно отправлять и принимать несколько кадров, увеличивая тем
  самым пропускную способность и эффективно использовать сетевые ресурсы, что полезно при загрузке больших ресурсов и
  выполнении множества запросов одновременно.

---

## 5.4 Тестирование

- Как тестировать свой код, какие встроенные инструменты используются?
- что такое CI/CD?

Пирамида тестирования
Кубок тестирования
там будут unit тесты и операционные тесты

https://habr.com/ru/companies/ecom_tech/articles/704342/
https://testengineer.ru/frontend-testing-guide/
https://forproger.ru/article/testirovanie-prilozhenij-s-pomoshhyu-jest-i-react-testing-library

### 5.4.0 Что я использую

Доступность:
WAVE — лучшее расширение для браузеров Chrome, Firefox или Microsoft Edge

Jest - это среда тестирования JavaScript, которая позволяет разработчикам запускать тесты на коде JavaScript и
TypeScript и хорошо интегрируется с React.

React Testing Library - это утилита для тестирования JavaScript, созданная специально для тестирования компонентов
React. Он имитирует взаимодействие пользователя с изолированными компонентами и утверждает их выходные данные, чтобы
гарантировать правильное поведение пользовательского интерфейса.

WebdriverCSS - на тестирование визуальной регрессии

### 5.4.1 Пирамида тестирования

- верх
- end-to-end тесты – воздействуют на систему через её внешние интерфейсы и проверяют ожидаемую реакцию системы через эти
  же интерфейсы.
- интеграционные тесты – тестируют взаимодействие между нашими модулями;
- юнит-тесты – используются для тестирования функций, модулей, классов в изоляции от всего приложения;
- низ

Также пирамида показывает, сколько тестов должно быть в проекте по пропорции. Юнит-тестов должно быть больше всего, а
end-to-end – меньше всего.

Чем ниже к основанию пирамиды располагаются тесты, тем они быстрее работают, тем стабильнее и быстрее пишутся. Но чем
выше тесты к вершине пирамиды, тем они приносят больше бизнес-ценности.

### 5.4.1 Кубок тестирования

В трофее тестирования у нас изменяется пропорция и добавляется дополнительный слой в самом основании – статические
тесты. Он отвечает за тестирование ошибок типов, то есть за типизацию, и за различные синтаксические ошибки. Это
достигается с помощью линтеров, Web IDE и какого-нибудь типизированного языка программирования, например, TypeScript. О
последнем я хочу рассказать вам историю из жизни.

### 5.4.3 CI/CD

Для начала небольшой ликбез. CI/CD расшифровывается как Continuous Integration и Continuous Delivery aka Deployment — то
есть непрерывная интеграция и непрерывная доставка.

### 5.4.4 CI

Голубая петля, CI, — это то, что мы делаем после того, как доработали новый функционал, и перед тем, как он пойдет в
деплой, чтобы стать доступным пользователям.

- линтеры
- тесты
- подготовка продакшен-билда

**Линтеры** — это статические анализаторы кода, которые его проверяют, не запуская. Они позволяют сократить время на
код-ревью и избавить разработчиков от рутинных задач: проверки стилистики кода (пробелы, точки с запятыми и длина
строки); поиска проблем и потенциальных багов: неиспользованные фрагменты кода, заведомо опасные или переусложненные
конструкции.

- ESLlint — де-факто стандартный линтер для JavaScript.
- TSLint — был основным линтером для TypeScript, однако разработчики отказываются от его поддержки в пользу ESLint.
- Prettier — не совсем линтер, скорее, форматтер, который следит за единой стилистикой кода; без проблем интегрируется с
  ESLint и TSLint.
- stylelint — линтер для CSS и самых популярных его диалектов (SASS, LESS), для которых у него есть плагины.

**Тесты.**
Перед тем как деплоить приложение, или даже строже: перед тем как вливать его в мастер, мы хотим убедиться в его
стабильности. Мы хотим знать, что приложение не сломается после запуска и что основные сценарии использования работают.
И мы хотим делать это автоматически.

- Jest, Mocha, Jasmine — фреймворки для организации и запуска тестов; в последнее время наиболее популярен Jest, так как
  он идет из коробки с Create React App.
- Testing Library, Enzyme — утилиты, в первую очередь нацеленные на тестирование веб-приложений (рендеринг, симуляция
  кликов и т. п.).
- selenium-webdriver, Cypress — инструменты для тестирования end-to-end, то есть когда будет действительно запускаться
  браузер и туда будут отправляться команды, эмулирующие действия пользователя (клики, нажатия клавиш и т. п.).

**Сборка** — это преобразование исходных файлов так, чтобы их можно было раздавать сервером как веб-сайт (то есть как
набор HTML-/JS-/CSS-файлов, которые понимает браузер), публиковать в менеджере пакетов (если вы пишете библиотеку,
фреймворк или утилиту), использовать как расширения для браузера, приложение на Electron и др.

- webpack, Parcel, Rollup, SystemJS, gulp, Grunt — основные сборщики приложений, которые решают большинство упомянутых
  задач.
- Dotenv, dotenv-cli — npm-пакеты, которые упрощают работу с переменными окружения, особенно при разработке.

### 5.4.5 CD

- версионирование и релиз
- деплоймент

Версионирование решает большое количество проблем: и при разработке библиотек и фреймворков, и связанных с
совместимостями. Сфокусируемся на проблемах, возникающих при разработке приложений для конечных пользователей. Их
помогают решить:

Маркеры стабильных ревизий. Упрощают поиск последней стабильной ревизии при необходимости откатить версию приложения (
если, например, критический баг попал в продакшен).

Именования для коммуникации. У вас появляется возможность обсуждать заливки, не называя их «то, где мы добавили профиль»
или «то, где мы пофиксили регистрацию», а используя номера версий — емкие и однозначные, писать более точные ченжлоги,
более эффективно исследовать и воспроизводить баги.

- Semantic Versioning — методология для формирования номера версии. Одна из многих, но именно эта используется для
  версионирования npm-пакетов (ее удобно совмещать с версией в package.json).
- Npm version, yarn version — команды, которые увеличивают версию вашего приложения. Они автоматически меняют версию в
  package.json, делают коммит с соответствующим сообщением и ставят тег, в котором будет имя новой версии.

Деплоймент — это доставка и выгрузка файлов в место, откуда они будут раздаваться. То, как происходит деплой в
значительной мере зависит от того, как именно хостится ваше приложение. Это может быть один из многих вариантов,
например: AWS S3 Bucket / AWS CloudFront / другой сервис AWS, коих множество, Heroku/Dokku, VPS/VPH.

Деплоймент — это просто выгрузка файлов на другой сервер. Разница лишь в протоколе, по которому она будет происходить:

- SSH — с некоторыми оговорками можно представить как пуш в некий удаленный (в смысле находящийся далеко) репозиторий.
- HTTP — простой и знакомый фронтендерам способ, когда каждый файл отправляется в теле соответствующего HTTP-запроса.
- FTP — самый старый из перечисленных протоколов, для которого можно найти клиент на Node.js, но, возможно, придется
  попотеть, настраивая его.

---

## 5.5 SOLID

- SOLID?

SOLID — это мнемоническая аббревиатура пяти принципов проектирования в объектно‑ориентированном программировании

- Single Responsobility - Принцип единственной ответственности, который подразумевает 1 сущность = 1 задача. Мы не
  делаем сущности, которые делают запросы, логируют что-то, сохраняют и т.д., это анти паттерн, такие сущности называют
  God object. В таком случае нужно декомпозировать сущность на несколько разных, которые выполняют одну задачу.
- Open-closed Principle - Принцип открытости/закрытости - Класс должен быть закрыт для изменения, но открыт для
  расширения. Пишем код так, чтобы другие могли легко расширить функционал, не меняя написанный (оттестированный,
  понравившийся твоему начальнику) код.
- Liskov Substitution Principle - Принцип подстановки Барбары Лисков - Если в коде программы Базовый класс заменить на
  его Наследника, то программа должна работать, так как в Наследнике есть все операции, которые были в Базовом. В
  Базовый класс нужно выносить только общую логику, которую наследники будут реализовывать. Наследников создаем только
  тогда, когда они правильно собираются реализовать логику Базового класса без проблем.
- Interface Segregation Principle - Принцип разделения интерфейса - Клиенты не должны зависеть от интерфейсов, которые
  они не используют. Большие интерфейсы следует разбивать на интерфейсы поменьше. Так клиенты смогут использовать только
  те интерфейсы, которые им нужны. Это делает менее связанный код, уменьшает зависимости между элементами системы,
  упрощает изменения в коде.
- Dependency Invertion Pronciple - Принцип инверсии зависимости - модули верхнего уровня не должны зависеть от модулей
  нижнего уровня. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от
  абстракций. Проще говоря, это означает, что вместо того, чтобы модуль верхнего уровня напрямую зависел от модулей
  нижнего уровня, оба модуля должны зависеть от общего интерфейса или абстракции. Таким образом, изменения в модуле
  нижнего уровня не должны затрагивать модуль верхнего уровня, а наоборот.

Остальные принципы:

- DRY/DIE - Don't Repeat Yourself / Duplication Is Evil.
- KISS Keep It Simple Stupid - призывает к тому, чтобы решения были максимально простыми. Он подразумевает, что чем
  проще и понятнее код, тем проще его поддерживать и изменять.
- YAGNI You Ain't Gonna Need It - не следует включать в программу функциональность, которая не требуется в данный
  момент. Он предостерегает от излишней сложности и избыточности кода.
- APO Avoid Premature Optimization - не следует оптимизировать код заранее, до того как станет ясно, что он
  действительно требует оптимизации. Ранняя оптимизация может привести к излишней сложности и утрате читаемости кода.

---

## 6 other

---

## 6.1 Реконсиляция

React Reconciliation - это рекурсивный алгоритм React, используемый для того, чтобы отличить текущее дерево элементов от
нового для определения частей, которые нужно будет заменить.

1. **Изменение состояния или пропсов:**
   Когда происходит изменение состояния/пропсов в React-компоненте, React создает новое виртуальное дерево элементов (*
   *Virtual DOM**) для представления обновленного состояния.
2. **Сравнение предыдущего и нового деревьев:**
   React берет предыдущее виртуальное дерево и новое виртуальное дерево, затем начинает сравнивать их, начиная с
   корневых элементов.
3. **Сравнение типов элементов:**
   Сначала React сравнивает типы элементов в предыдущем и новом деревьях. Если типы разные, React полностью удаляет
   старый элемент и все его дочерние элементы из реального DOM.
4. **Сравнение дочерних элементов:**
   Если типы элементов совпадают, React рекурсивно сравнивает дочерние элементы обоих деревьев.
5. **Определение изменений:**
   В процессе сравнения React определяет, какие части дерева изменились. Это может включать в себя добавление, удаление
   или обновление компонентов.
6. **Пакет обновлений (Batch Updates)**:
   React группирует изменения, чтобы минимизировать количество манипуляций DOM и повысить производительность. Это
   означает, что React не обновляет DOM после каждого изменения, а собирает все изменения и применяет их одновременно.
7. **Применение изменений:**
   React применяет эти изменения к реальному DOM. Если компонент был изменен, React обновит его атрибуты и содержимое.
   Если компонент был добавлен, React добавит его в DOM. Если компонент был удален, React удаляет его из DOM.

---

## 6.2 Критические этапы рендеринга

- **Парсинг HTML и создание DOM.**
- **DOM** ответы в виде HTML превращаются в токены, которые в свою очередь превращаются в узлы и в последующем формируют
  DOM дерево.
- **CSSOM** все данные о том как стилизовать DOM.
- **JavaScript** загрузка всех скриптов.
- **Accessibility Tree** при парсинге HTML, анализируются специальные атрибуты по типу role и aria.
- **Render Tree** Соединение DOM и CSSOM.
- **Layout/Reflow** - это процесс определения размеров и позиций всех элементов на странице, а также их отношений друг к
  другу. Это происходит на основе CSS-правил и содержимого страницы.
- **Paint/Repaint** это процесс рендеринга элементов на странице. Он включает в себя применение цветов, текстур,
  градиентов и других стилей к элементам.
- **Compositing**  техника разделения частей страницы на слои, их раздельной отрисовки и компоновки в виде страницы в
  отдельном потоке, называемом потоком композитора. Когда части документа рисуются в разных слоях, накладываясь друг на
  друга, композитинг необходим для того, чтобы они выводились на экран в правильном порядке и содержимое отображалось
  корректно. При этом используются мощности GPU.

---

## 6.3 Процесс загрузки

https://vc.ru/selectel/76371-chto-proishodit-kogda-polzovatel-nabiraet-v-brauzere-adres-saita

- Вы вводите адрес
- Браузер ищет в своем кэше запись о DNS. Он проверяет 4 кэша: браузера, операционной системы, роутера, провайдера
- DNS запрос ищет нужный IP на разных DNS серверах, сперва в Local DNS resolver, который поставляется провайдером. Он в
  свою очередь сначала идет к Root Server, который дает ему TLD Top Level Domain(например .ru) сервер и так по цепочке.
- Браузер инициализирует TCP соединение с сервером
- Браузер посылает HTTP запрос на получение нужной страницы
- Сервер обрабатывает запрос и высылает ответ. Вместе с этим высылает куки файл, которым ПК и сервер обмениваются при
  каждом запросе.
- Рендерится HTML разметка
- Проверяются HTML теги и отсылаются GET запросы на получение дополнительных элементов. Файлы кэшируются
- Отображается страница в браузере

---

## 6.4 ООП

- Абстракция - представляет собой концепцию, которая позволяет скрыть детали реализации объекта и предоставить только
  необходимый набор данных и операций для работы с ним. Это как использование автомобиля без необходимости знать, как он
  работает внутри. Вам не нужно знать, как каждая деталь двигателя взаимодействует друг с другом; вам просто нужно
  знать, как управлять машиной с помощью руля и педалей. Абстракция в программировании позволяет скрыть сложные детали
  реализации, чтобы облегчить использование объекта или системы.
- Наследование - способность объекта/класса наследоваться от другого объекта/класса. Наследование позволяет создавать
  новые классы на основе существующих (родительских) классов. Подкласс (или дочерний класс) наследует свойства и методы
  родительского класса, а также может определять свои собственные свойства и методы. Это позволяет избегать повторного
  кодирования и обеспечивает повторное использование кода.
- Инкапсуляция - объединение данных и методов, которые работают с этими данными, в единый объект/класс. Объект скрывает
  свою внутреннюю реализацию от внешнего мира, предоставляя только определенные методы и свойства для взаимодействия,
  делается это с помощью геттеров и сеттеров, публичных и приватных полей в объекте/классе. Это позволяет обеспечить
  безопасность данных и упрощает их использование.
- Полиморфизм - позволяет объектам разных классов реагировать на вызовы методов с одинаковыми именами разным для каждого
  класса способом. Это делает код более гибким и легким для поддержки и расширения, поскольку различные объекты могут
  вести себя по-разному, но при этом использовать общий интерфейс для взаимодействия с ними.

---

## 6.5 ФП

- Чистые функции (Pure Functions): Чистые функции - это функции, которые при одних и тех же входных данных всегда
  возвращают одинаковый результат и не имеют побочных эффектов, то есть они не изменяют состояние программы или внешние
  данные.
- Неизменяемость (Immutability): Данные в функциональном программировании обычно считаются неизменяемыми, что означает,
  что после создания структура данных не может быть изменена. Вместо этого операции над данными создают новые структуры
  данных.
- Функции высшего порядка (Higher-Order Functions): Функции высшего порядка - это функции, которые могут принимать
  другие функции в качестве аргументов или возвращать их в качестве результатов. Они позволяют создавать более
  абстрактные и гибкие функции.
- Рекурсия (Recursion): Рекурсия широко используется в функциональном программировании вместо циклов для выполнения
  итераций.
- Композиция функций (Function Composition): Композиция функций - это процесс комбинирования нескольких функций в одну,
  чтобы создать новую функцию.
- Преобразование данных (Data Transformation): Функциональное программирование поддерживает мощные средства для
  преобразования данных с помощью функций отображения, фильтрации и свертки.
- Строгая типизация (Strong Typing): Некоторые языки функционального программирования имеют строгую типизацию, которая
  обеспечивает большую надежность программ и упрощает рефакторинг.

---

## 6. text

text

---
